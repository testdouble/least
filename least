#!/usr/bin/env ruby
require 'io/console'
require 'io/wait'

module Comparable
  def clamp(min,max)
    [min,self,max].sort[1]
  end
end

KEY_CTRL_C = ?\C-c
KEY_CTRL_P = ?\C-p
KEY_CTRL_N = ?\C-n

class ANSI
  ESC = 27.chr

  class << self
    def escape(sequence)
      ESC + "[" + sequence
    end

    def clear
      escape "2J"
    end

    def cursor_top
      escape "H"
    end

    def cursor_beginnning_of_line
      escape "G"
    end
  end
end

class TTY < Struct.new(:console_file)
  def self.with_tty(&block)
    # Selecta reads data from stdin and writes it to stdout, so we can't draw
    # UI and receive keystrokes through them. Fortunately, all modern
    # Unix-likes provide /dev/tty, which IO.console gives us.
    console_file = IO.console
    tty = TTY.new(console_file)
    block.call(tty)
  end

  def clear
    print ANSI.clear
    print ANSI.cursor_top
  end

  def get_available_input
    console_file.getc if console_file.ready?
  end

  def winsize
    console_file.winsize
  end

  def height
    winsize.first
  end

  def width
    winsize.last
  end

  def stty(args)
    command("stty #{args}").strip
  end

  def write_line(line)
    console_file.puts line
    print ANSI.cursor_beginnning_of_line
  end

  private

  # Run a command with the TTY as stdin, capturing the output via a pipe
  def command(command)
    IO.pipe do |read_io, write_io|
      pid = Process.spawn(command, :in => "/dev/tty", :out => write_io)
      Process.wait(pid)
      raise "Command failed: #{command.inspect}" unless $?.success?
      write_io.close
      read_io.read
    end
  end
end

class Terminal
  attr_reader :tty, :buffer, :current_line_index

  def initialize(tty, buffer, current_line_index = 0, paused = true)
    @tty = tty
    @buffer = buffer
    @current_line_index = current_line_index.clamp(0,buffer.count-1) if paused
    @paused = paused
  end

  def current_height
    tty.height
  end

  def view
    if @paused
      pad(buffer[current_line_index...(current_line_index+current_height)])
    else
      beginning_index = buffer.count - current_height
      buffer[beginning_index..-1]
    end
  end

  def pad(arr)
    padding_needed = [0, current_height - arr.size].max
    arr + ([''] * padding_needed)
  end

  def move_down
    Terminal.new(tty, buffer, current_line_index + 1)
  end

  def move_up
    Terminal.new(tty, buffer, current_line_index - 1)
  end

  def pause
    current_line = (buffer.count - current_height).clamp(0, buffer.count)
    Terminal.new(tty, buffer, current_line, true)
  end

  def resume
    Terminal.new(tty, buffer, nil, false)
  end

  def toggle_pause
    if @paused
      resume
    else
      pause
    end
  end

  def refresh
    tty.clear
    view.each do |line|
      tty.write_line line
    end
  end
end

class Least
  attr_reader :tty, :terminal, :buffer

  def main
    @tty = TTY.new(IO.console)
    @buffer = []
    @terminal = Terminal.new(tty, buffer, nil, false)
    original_tty_state = tty.stty("-g")
    tty.stty("raw")

    loop do
      old_view = terminal.view
      handle_user_input
      handle_piped_input
      terminal.refresh unless old_view == @terminal.view
    end
  rescue Interrupt, RuntimeError
    puts "Exiting..."
  ensure
    tty.stty(original_tty_state)
  end

  def handle_user_input
    input = tty.get_available_input

    # Handle special characters
    case input
    when KEY_CTRL_C
      raise "We should exit now"
    when KEY_CTRL_N
      @terminal = terminal.move_down
    when KEY_CTRL_P
      @terminal = terminal.move_up
    when ' '
      @terminal = terminal.toggle_pause
    end
  end

  def handle_piped_input
    return if STDIN.eof?

    buffer << STDIN.readline
  end
end

if __FILE__ == $0
  Least.new.main
end
